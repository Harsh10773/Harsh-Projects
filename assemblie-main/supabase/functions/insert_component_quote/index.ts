
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.15.0";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }
  
  try {
    // Parse request body
    const { vendorId, orderId, orderItemId, quotedPrice, componentName, quantity } = await req.json();
    
    // Validate input data
    if (!vendorId || !orderId || !orderItemId || quotedPrice === undefined) {
      console.error("Missing required fields:", { vendorId, orderId, orderItemId, quotedPrice });
      return new Response(
        JSON.stringify({ error: "Missing required fields" }),
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    console.log(`Processing quote: vendorId=${vendorId}, orderId=${orderId}, itemId=${orderItemId}, price=${quotedPrice}, component=${componentName}, quantity=${quantity || 1}`);
    
    // Create a Supabase client with service role key (bypassing RLS)
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const serviceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    
    if (!supabaseUrl || !serviceRoleKey) {
      console.error("Missing environment variables");
      return new Response(
        JSON.stringify({ error: "Server configuration error" }),
        { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }
    
    const supabase = createClient(supabaseUrl, serviceRoleKey);
    
    // Handle special fallback item ID (starts with "fallback-" or "temp-")
    let exactComponentName = componentName || "Unknown Component";
    let componentDetails = null;
    let isAutoGenerated = false;
    
    // Check if this is a fallback/autogenerated component ID
    if (orderItemId.startsWith('fallback-') || orderItemId.startsWith('temp-')) {
      isAutoGenerated = true;
      console.log(`Processing autogenerated component ID: ${orderItemId}`);
      
      // For autogenerated components, use the provided component name
      exactComponentName = componentName || "Complete Computer Build";
      componentDetails = {
        name: exactComponentName,
        category: "System",
        description: "Complete computer build as specified by customer",
        specs: "Full system build",
        original_name: exactComponentName
      };
    } else {
      // CRITICAL: Get the exact component name and details from customer_ordered_components
      // First check customer_ordered_components - this has the most accurate info
      const { data: customerComponent } = await supabase
        .from('customer_ordered_components')
        .select('component_name, component_details, component_category, component_id')
        .eq('id', orderItemId)
        .maybeSingle();
        
      if (customerComponent && customerComponent.component_name) {
        // Get the component details and extract the full model name
        const compDetails = customerComponent.component_details || {};
        let fullModelName = '';
        
        // Check if component details is an object (not an array)
        if (compDetails && typeof compDetails === 'object' && !Array.isArray(compDetails)) {
          // First try to use the original name that was saved when user selected the component
          if (compDetails.original_name) {
            fullModelName = compDetails.original_name;
          }
          // Try to build a detailed component name from the component details
          else if (compDetails.brand && compDetails.model) {
            fullModelName = `${compDetails.brand} ${compDetails.model}`;
          } else if (compDetails.original_name) {
            fullModelName = compDetails.original_name;
          } else if (compDetails.name) {
            fullModelName = compDetails.name;
          }
          
          // Add specific details based on component category
          if (customerComponent.component_category?.toLowerCase().includes('processor')) {
            if (compDetails.cores) {
              fullModelName += ` (${compDetails.cores} cores`;
              if (compDetails.clock_speed) fullModelName += `, ${compDetails.clock_speed}GHz`;
              fullModelName += ')';
            }
          } else if (customerComponent.component_category?.toLowerCase().includes('graphics')) {
            if (compDetails.vram || compDetails.memory) {
              fullModelName += ` (${compDetails.vram || compDetails.memory}GB)`;
            }
          }
        }
        
        // If we don't have detailed model name but have component_id, try to get from components table
        if (!fullModelName && customerComponent.component_id) {
          const { data: componentData } = await supabase
            .from('components')
            .select('name')
            .eq('id', customerComponent.component_id)
            .maybeSingle();
            
          if (componentData && componentData.name) {
            fullModelName = componentData.name;
          }
        }
        
        // Use the built model name or fall back to the component name
        exactComponentName = fullModelName || customerComponent.component_name;
        componentDetails = compDetails;
        console.log(`Found exact component from customer_ordered_components: ${exactComponentName}`);
      } else {
        // If not found in customer_ordered_components, check order_items
        const { data: orderItem } = await supabase
          .from('order_items')
          .select('component_name, component_id')
          .eq('id', orderItemId)
          .maybeSingle();
          
        if (orderItem && orderItem.component_name) {
          exactComponentName = orderItem.component_name;
          console.log(`Found exact component from order_items: ${exactComponentName}`);
          
          // Try to get more details if we have a component_id
          if (orderItem.component_id) {
            const { data: componentData } = await supabase
              .from('components')
              .select('*')
              .eq('id', orderItem.component_id)
              .maybeSingle();
              
            if (componentData) {
              componentDetails = componentData;
              // Make sure the component details has the exact name from order_items
              componentDetails.name = exactComponentName;
              
              // Build a more detailed name if we have brand and model
              if (componentData.brand && componentData.model) {
                exactComponentName = `${componentData.brand} ${componentData.model}`;
              }
            }
          }
        } else {
          // Check user_builds if the ID matches
          const { data: userBuild } = await supabase
            .from('user_builds')
            .select('model_name, component_type')
            .eq('id', orderItemId)
            .maybeSingle();
            
          if (userBuild && userBuild.model_name) {
            exactComponentName = userBuild.model_name;
            componentDetails = {
              name: userBuild.model_name,
              category: userBuild.component_type || 'component',
              description: userBuild.model_name,
              specs: `${userBuild.model_name} - ${userBuild.component_type}`
            };
            console.log(`Found component from user_builds: ${exactComponentName}`);
          } else {
            // Last resort: Use the provided name
            console.log(`No exact component name found, using provided name: ${exactComponentName}`);
            
            // Create basic component details if we don't have any
            if (!componentDetails) {
              componentDetails = {
                name: exactComponentName,
                category: inferComponentCategory(exactComponentName),
                description: exactComponentName
              };
            }
          }
        }
      }
    }
    
    try {
      // For autogenerated components, we need to create a unique entry in the history table
      if (isAutoGenerated) {
        console.log(`Inserting autogenerated component quote for ${exactComponentName}`);
        
        // Direct insert into history table
        const { data: insertedData, error: insertError } = await supabase
          .from('vendor_component_quotations_history')
          .insert([{
            vendor_id: vendorId,
            order_id: orderId,
            order_item_id: orderItemId,
            component_name: exactComponentName,
            quoted_price: quotedPrice,
            quantity: quantity || 1,
            status: 'pending'
          }])
          .select()
          .single();
        
        if (insertError) {
          console.error('Error inserting autogenerated component quote:', insertError);
          throw insertError;
        }
        
        console.log('Autogenerated quote inserted successfully:', insertedData);
        
        return new Response(
          JSON.stringify({ 
            success: true, 
            data: insertedData,
            componentName: exactComponentName,
            componentDetails,
            isAutoGenerated: true
          }),
          { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }
      
      // For regular components, use the RPC function
      const { data, error } = await supabase.rpc('insert_component_quote_history', {
        vendor_id_param: vendorId,
        order_id_param: orderId,
        order_item_id_param: orderItemId,
        component_name_param: exactComponentName,
        quoted_price_param: quotedPrice,
        quantity_param: quantity || 1
      });
      
      if (error) {
        console.error('Error with RPC insert_component_quote_history:', error);
        throw error;
      }
      
      console.log('Quote inserted successfully with exact component name:', exactComponentName);
      
      return new Response(
        JSON.stringify({ 
          success: true, 
          data,
          componentName: exactComponentName,
          componentDetails
        }),
        { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    } catch (error) {
      console.error('Error in quote insertion:', error);
      return new Response(
        JSON.stringify({ error: error.message || 'Failed to insert quote' }),
        { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }
  } catch (error) {
    console.error('Unexpected error:', error);
    return new Response(
      JSON.stringify({ error: 'Unexpected error occurred' }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});

// Helper function to infer component category from name
function inferComponentCategory(componentName: string): string {
  const name = componentName.toLowerCase();
  
  if (name.includes('processor') || name.includes('cpu') || name.includes('ryzen') || name.includes('intel')) {
    return 'processor';
  } else if (name.includes('graphics') || name.includes('gpu') || name.includes('rtx') || name.includes('gtx')) {
    return 'graphics';
  } else if (name.includes('memory') || name.includes('ram') || name.includes('ddr')) {
    return 'memory';
  } else if (name.includes('storage') || name.includes('ssd') || name.includes('hdd') || name.includes('nvme')) {
    return 'storage';
  } else if (name.includes('cooling') || name.includes('cooler') || name.includes('fan')) {
    return 'cooling';
  } else if (name.includes('power') || name.includes('psu') || name.includes('supply')) {
    return 'power';
  } else if (name.includes('motherboard') || name.includes('mobo')) {
    return 'motherboard';
  } else if (name.includes('case')) {
    return 'pcCase';
  }
  
  return 'other';
}
